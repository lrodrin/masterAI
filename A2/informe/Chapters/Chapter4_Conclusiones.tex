En este informe se ha intentado describir teóricamente las codificaciones de los algoritmos que se han implementado para el trabajo final de la asignatura. También como parte de una pequeña investigación sobre el problema de la partición de grafos y algunas codificaciones existentes.

La elección de los algoritmos para su codificación se ha basado en mostrar los algoritmos más conocidos y utilizados para el problema de la partición de grafos. Se han implementado en Python porqué es un lenguaje de programación cuya filosofía hace hincapié en la legibilidad de su código, que es un lenguaje muy utilizado en Inteligencia Artificial, y que además es un lenguaje interpretado, dinámico y multiplataforma. 

Al final de este proceso hemos utilizado diferentes grafos aleatorios no dirigidos para la comparación de los tres algoritmos descritos y codificados. Estos grafos no son muy grandes, ya que lo difícil de este trabajo final era la implementación de los tres algoritmos y se la ha dado más peso en este caso. Aun así, al comparar los algoritmos hemos podido observar su comportamiento, como por ejemplo que el algoritmo Multilevel Spectral Bisection es el algoritmo más eficiente que se ha codificado y que el algoritmo Kernighan-Lin es el menos eficiente. También hemos observado una diferencia importante durante la comparación, que es que el algoritmo de bisección espectral nos ha creado dos particiones no equilibradas.

Como cualquier de las codificaciones nos puede dar una solución óptima, en la comparación de los algoritmos solo se ha tenido en cuenta su tiempo de ejecución. En ese tiempo de ejecución, no se ha añadido el tiempo empleado en la creación de los grafos, antes y después de las particiones. 

Otro motivo es que cada vez que hemos ejecutado uno de los algoritmos, las soluciones han cambiado. Así que, por eso también los hemos comparado por tiempo de ejecución. Como sabemos, al ser algoritmos metaheurísticos, todas las soluciones pueden ser óptimas y válidas. Eso quiere decir que, aunque un algoritmo sea más eficiente, no obtendrá siempre la mejor solución. Porqué como hemos visto, a menudo no existe una relación entre el tiempo de ejecución y la calidad de la solución. Algunos algoritmos funcionan muy rápido pero solo encuentran una solución de calidad media, mientras que otros que tardan mucho tiempo pueden ofrecen soluciones excelentes. La elección del tiempo frente a la calidad se ha descrito más detalladamente en la sección \ref{chapter:Comparativa}.

Para finalizar, comentar que en las secciones anteriores siempre se ha hablado de minimizar el tamaño de las conexiones entre los vértices de los grafos en ciertas condiciones. Pero para todos menos algunos gafos bien estructurados o pequeños (casos no triviales), la minimización real no es factible porque tomaría mucho tiempo. En pocas palabras, hemos comprobado que no hay un algoritmo conocido que sea mucho más rápido que probar todas las combinaciones posibles y que hay pocas esperanzas de que se encuentre alguno. Un poco más exacto (pero aún ignorando algunos fundamentos de la teoría NP), significa por ejemplo, que la bisección del grafo cae en una gran clase de problemas, todos los cuales pueden transformarse entre sí y para los cuales no hay algoritmos conocidos que puedan resolver el problema en tiempo polinómico, con un tamaño del grafo de entrada muy grande. Entonces, en lugar de encontrar la solución óptima, por eso hemos recorrido a la metaheurísitica.