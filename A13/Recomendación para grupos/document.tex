\documentclass{uimppracticas}

%Permitir cabeceras y pie de páginas personalizados
\pagestyle{fancy}

%Path por defecto de las imágenes
\graphicspath{ {./images/} }

%Declarar formato de encabezado y pie de página de las páginas del documento
\fancypagestyle{doc}{
	%Pie de Página
	\footerpr{}{}{{\thepage} de \pageref{LastPage}}
}

%Declarar formato de encabezado y pie del título e indice
\fancypagestyle{titu}{%
	%Cabecera
	\headerpr{}{}{}
	%Pie de Página
	\footerpr{}{}{}
}

\appto\frontmatter{\pagestyle{titu}}
\appto\mainmatter{\pagestyle{doc}}

\begin{document}
	
%Comienzo formato título
\frontmatter

%Portada (Centrado todo)
\centeredtitle{./images/LogoUIMP.png}{Máster Universitario en Investigación en Inteligencia Artificial}{Curso 2020-2021}{Sistemas de Recomendación}{Recomendación para grupos \\ en Python}

\begin{center}
	\large \today
\end{center}

\vspace{40mm}

\begin{flushright}
	{\bf Laura Rodríguez Navas}\\
	\textbf{DNI:} 43630508Z\\
	\textbf{e-mail:} \href{rodrigueznavas@posgrado.uimp.es}{rodrigueznavas@posgrado.uimp.es}
\end{flushright}

\newpage

%Índice
\tableofcontents

\newpage

%Comienzo formato documento general
\mainmatter

\setlength\parskip{2.5ex}

\section{Introducción}\label{introducción}

\newpage

\section{Conjunto de datos}

El conjunto de datos que se ha usado en esta práctica se encuentra disponible públicamente para su descarga en el siguiente enlace: \url{https://www.kaggle.com/abhikjha/movielens-100k/download}. Este conjunto de datos llamado \textit{ml-latest-small}, describe las valoraciones (entre 1 y 5 estrellas) y la actividad del etiquetado de \href{http://movielens.org}{MovieLens}~\cite{MovieLens}, un servicio de recomendación de películas. Concretamente, el conjunto de datos contiene 100836 clasificaciones y 3683 etiquetas de 9742 películas. Los datos fueron creados por 610 usuarios que fueron seleccionados al azar. Cada usuario clasificó al menos 20 películas y está representado por una identificación.

Una vez descargado el conjunto de datos veremos que está contenido en los archivos \textit{links.csv}, \textit{movies.csv}, \textit{ratings.csv} y \textit{tags.csv}. Pero para el desarrollo de esta práctica solo se utilizan los archivos \textit{movies.csv} y \textit{ratings.csv}. A continuación, cargamos cada archivo dentro de su dataframe (ver Definición~\ref{dataframe}) con el uso de la librería pandas~\cite{pandas}.

\begin{lstlisting}[language=python]
movies_df = pd.read_csv('dataset/movies.csv')
ratings_df = pd.read_csv('dataset/ratings.csv')
\end{lstlisting}

Observamos el contenido de \textit{movies\_df} para ver como ha quedado organizado:

\begin{table}[h]
	\centering
	\begin{tabular}{rll}
		\toprule
		movieId &                               title &                                       genres \\
		\midrule
		1 &                    Toy Story (1995) &  Adventure|Animation|Children|Comedy|Fantasy \\
		2 &                      Jumanji (1995) &                   Adventure|Children|Fantasy \\
		3 &             Grumpier Old Men (1995) &                               Comedy|Romance \\
		4 &            Waiting to Exhale (1995) &                         Comedy|Drama|Romance \\
		5 &  Father of the Bride Part II (1995) &                                       Comedy \\
		\bottomrule
	\end{tabular}
	\caption{Contenido del dataframe \textit{movies\_df} inicialmente.}
	\label{movies_df}
\end{table}

Cada película tiene un único identificador, un título con su año de estreno y diferentes géneros. Como los años contienen caracteres \textit{unicode} y para que no haya problemas más adelante, los sacaremos de la columna de los títulos y los ubicaremos en su propia columna que nombraremos \textit{year}. Para ello, primero utilizamos una expresión regular para encontrar los años guardados entre paréntesis, y con la función \textit{extract} de la librería pandas los extraemos de la columna de los títulos para guardarlos en su propia columna. Después borramos los años de la columna de los títulos y con la función \textit{strip} nos aseguramos de sacar los espacios finales que pudiera haber.

\begin{lstlisting}[language=python]
regular_expression = r'\((.*?)\)'
movies_df['year'] = movies_df.title.str.lower().str.extract(regular_expression)
movies_df['title'] = movies_df.title.str.replace(regular_expression, '', regex=True)
movies_df['title'] = movies_df['title'].apply(lambda x: x.strip())
\end{lstlisting}

Vemos el resultado:

\begin{table}[h]
	\centering
	\begin{tabular}{rlll}
		\toprule
		movieId &                        title &                                       genres &  year \\
		\midrule
		1 &                    Toy Story &  Adventure|Animation|Children|Comedy|Fantasy &  1995 \\
		2 &                      Jumanji &                   Adventure|Children|Fantasy &  1995 \\
		3 &             Grumpier Old Men &                               Comedy|Romance &  1995 \\
		4 &            Waiting to Exhale &                         Comedy|Drama|Romance &  1995 \\
		5 &  Father of the Bride Part II &                                       Comedy &  1995 \\
		\bottomrule
	\end{tabular}
	\caption{Contenido del dataframe \textit{movies\_df} con la columna \textit{year}.}
	\label{movies_df_years}
\end{table}

Eliminamos la columna de los géneros, ya que no los tendremos en cuenta para el sistema de recomendación.

\begin{lstlisting}[language=python]
movies_df = movies_df.drop('genres', 1)
\end{lstlisting}

Finalmente, así queda el dataframe \textit{movies\_df}:

\begin{table}[h]
	\centering
	\begin{tabular}{rll}
		\toprule
		movieId &                        title &  year \\
		\midrule
		1 &                    Toy Story &  1995 \\
		2 &                      Jumanji &  1995 \\
		3 &             Grumpier Old Men &  1995 \\
		4 &            Waiting to Exhale &  1995 \\
		5 &  Father of the Bride Part II &  1995 \\
		\bottomrule
	\end{tabular}
	\caption{Contenido del dataframe \textit{movies\_df} final.}
	\label{movies_df_final}
\end{table}

\begin{definition}\label{dataframe}
	Un DataFrame es una estructura de datos etiquetada bidimensional que acepta diferentes tipos datos de entrada organizados en columnas. Se puede pensar en un DataFrame como una hoja de cálculo o una tabla SQL.
\end{definition}

Ahora, veremos cómo se ha organizado el dataframe \textit{ratings\_df}. En este caso también hemos eliminado una columna, la columna \textit{timestamp}, ya que tampoco se tendrá en cuenta en el sistema de recomendación.

\begin{lstlisting}[language=python]
ratings_df = ratings_df.drop('timestamp', 1)
\end{lstlisting}

Finalmente, así queda el dataframe \textit{ratings\_df}:

\begin{table}[h]
	\centering
	\begin{tabular}{rrr}
		\toprule
		userId &  movieId &  rating \\
		\midrule
		1 &        1 &     4.0 \\
		1 &        3 &     4.0 \\
		1 &        6 &     4.0 \\
		1 &       47 &     5.0 \\
		1 &       50 &     5.0 \\
		\bottomrule
	\end{tabular}
	\caption{Contenido del dataframe \textit{ratings\_df} final.}
	\label{ratings_df_final}
\end{table}


Cada fila del dataframe \textit{ratings\_df} tiene un identificador de usuario asociado con al menos una película, el identificador de la película y una valoración de esta. 

\newpage

\section{Filtrado Colaborativo}

En esta sección, describiremos el sistema de recomendación basado en usuarios que ha sido desarrollado en Python~\cite{GitHubRepo}.

Como hemos comentado en la sección de Introducción (ver sección~\ref{introducción}), la técnica que usaremos y que hemos desarrollado para el sistema de recomendación se llama \href{https://es.wikipedia.org/wiki/Filtrado_colaborativo}{Filtrado Colaborativo}. El Filtrado Colaborativo también es conocido como Filtrado de Usuario a Usuario. Con esta técnica utilizaremos los usuarios del conjunto de datos para recomendar películas a un nuevo usuario que añadirá nuevos datos al sistema. Para ello, el sistema de recomendación intentará encontrar usuarios que tengan valoraciones parecidas a las del nuevo usuario, y entonces recomendarle al nuevo usuario películas acordes a sus valoraciones. Para encontrar usuarios parecidos existen varios métodos, en el caso de la práctica el método elegido se basa en el \href{https://es.wikipedia.org/wiki/Coeficiente_de_correlaci\%C3\%B3n_de_Pearson}{coeficiente de correlación de Pearson}. 

El proceso para crear el sistema de recomendación sigue los siguientes pasos:

\begin{itemize}
	\item Crear un nuevo usuario con las películas del conjunto de datos que el usuario a mirado.
	\item Basado en su índice de selección de películas, encontrar a los primeros X vecinos.
	\item Obtener el identificador de las películas que miró el nuevo usuario por cada vecino.
	\item Calcular las similitudes entre los usuarios existentes y el nuevo usuario.
	\item Recomendar películas al nuevo usuario con las puntuaciones más altas.
\end{itemize}

Así, comenzamos creando un nuevo usuario a quien recomendar películas. Para ello, creamos el archivo \textit{dataset/user\_ratings.csv} que contiene 100 películas elegidas aleatoriamente del conjunto de datos, y a continuación las valoramos. En este caso, he valorado las películas según mi criterio. Este archivo se puede modificar como se desee para realizar tantas recomendaciones como se quiera, solo nos debemos asegurar de escribir los títulos de las películas en mayúsculas y si una película comienza con un "The", como "The Matrix" entonces escribirlo así: "Matrix, The". Para finalizar con la creación del nuevo usuario, el archivo \textit{dataset/user\_ratings.csv} se carga dentro de un nuevo dataframe:

\begin{lstlisting}[language=python]
user_df = pd.read_csv('dataset/user_ratings.csv')
\end{lstlisting}

Con los datos del nuevo usuario en el sistema de recomendación, extraeremos los identificadores de las películas del dataframe de películas, para agregarlos con los nuevos datos añadidos por el usuario. Para ello, primero se extraen los títulos de las películas que el usuario haya visto para luego juntarlas con los datos del usuario. En este punto también, vamos a aprovechar a eliminar información que no se utilizará más adelante en el sistema de recomendación, como la columna \textit{year}, para ahorrar espacio de memoria.

\begin{lstlisting}[language=python]
titles = movies_df[movies_df['title'].isin(user_df['title'].tolist())]
user_df = pd.merge(titles, user_df)
user_df = user_df.drop('year', 1)
\end{lstlisting}

\newpage

Vemos el resultado:

\begin{table}[h]
	\centering
	\begin{tabular}{rlr}
		\toprule
		movieId &                        title &  rating \\
		\midrule
		1 &                    Toy Story &     5.0 \\
		2 &                      Jumanji &     5.0 \\
		3 &             Grumpier Old Men &     1.0 \\
		4 &            Waiting to Exhale &     1.0 \\
		5 &  Father of the Bride Part II &     1.0 \\
		\bottomrule
	\end{tabular}
	\caption{Contenido del dataframe \textit{user\_df}.}
	\label{user_df}
\end{table}

Ahora, que hemos añadido los identificadores de las películas con los datos del nuevo usuario, podemos obtener el subconjunto de usuarios que han visto las mismas películas. Además, también agruparemos las filas por el identificador de usuario.

\begin{lstlisting}[language=python]
user_titles = ratings_df[ratings_df['movieId'].isin(user_df['movieId'].tolist())]
user_groups = user_titles.groupby(['userId'])
\end{lstlisting}

Observaremos a uno de los usuarios, por ejemplo, el usuario 525.

\begin{table}[h]
	\centering
	\begin{tabular}{rrr}
		\toprule
		userId &  movieId &  rating \\
		\midrule
		525 &        1 &     4.0 \\
		525 &        2 &     3.5 \\
		525 &       34 &     3.0 \\
		525 &       39 &     4.5 \\
		525 &       48 &     3.0 \\
		\bottomrule
	\end{tabular}
\caption{Contenido del dataframe \textit{user\_df}.}
\label{user_525}
\end{table}

Finalmente, ordenaremos el conjunto de datos de tal forma que los usuarios que compartan la mayor cantidad de películas tengan prioridad. Esto nos brindaré una mejor recomendación ya que no será necesario pasar por todos los usuarios. 

\begin{lstlisting}[language=python]
user_groups = sorted(user_groups, key=lambda x: len(x[1]), reverse=True)
\end{lstlisting}

\subsection{Similitud entre los usuarios y el nuevo usuario}

\newpage

\section{Conclusiones}

Automatizar la creación del archivo \textit{dataset/user\_ratings.csv}.

\newpage

\renewcommand{\refname}{Bibliografía}
\bibliographystyle{unsrt}
\bibliography{biblio}
	
\end{document}
