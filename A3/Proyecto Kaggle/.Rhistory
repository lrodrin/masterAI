newdata <- data.frame(train_dat[,-3])
train_dat$model_prob <- predict(model, newdata, type = "response")
train_dat <- train_dat  %>% mutate(model_pred = 1*(model_prob > .53) + 0,
shot_made_flag = 1*(shot_made_flag == 1) + 0)
train_dat  %>% mutate(model_pred = 1*(model_prob > .53) + 0,
shot_made_flag = 1*(shot_made_flag == 1) + 0)
train_dat$model_prob <- predict(model, newdata, type = "response")
train_dat %>% mutate(model_pred = 1*(model_prob > .53) + 0,
shot_made_flag = 1*(shot_made_flag == 1) + 0)
newdata <- data.frame(train_dat[,-3])
train_dat$model_prob <- predict(model, newdata, type = "response")
train_dat <- train_dat %>% mutate(accurate = 1*(model_pred == shot_made_flag))
library(dplyr)
#show accuracy by train data
newdata <- data.frame(train_dat[,-3])
train_dat$model_prob <- predict(model, newdata, type = "response")
train_dat <- train_dat %>% mutate(accurate = 1*(model_pred == shot_made_flag))
newdata <- data.frame(train_dat[,-3])
train_dat$model_prob <- predict(model, newdata, type = "response")
train_dat <- train_dat %>% mutate(accurate = 1*(model_prob == shot_made_flag))
sum(train_dat$accurate)/nrow(train_dat)
train_dat$shot_made_flag <- myNormalize(train_dat$shot_made_flag)
train_dat <- train_dat %>% mutate(accurate = 1*(model_prob == shot_made_flag))
sum(train_dat$accurate)/nrow(train_dat)
glm <- glm(shot_made_flag~., data=train_dat, family = binomial(link = "logit"))
pred <- predict(glm, train_dat)
trainig_error <- mean(train_dat$shot_made_flag != pred) * 100
paste("Trainig_error =", trainig_error, "%")
confusionMatrix(pred, train_dat$shot_made_flag)
library(caret)
library(MASS)
library(randomForest)
data <- read.csv("data.csv", sep = "," , stringsAsFactors = FALSE)
cat("splitting data to train and test......\n")
train <- subset(data, !is.na(data$shot_made_flag))
test <- subset(data, is.na(data$shot_made_flag))
cat("precessing the train data......\n")
train$shot_made_flag <- as.factor(train$shot_made_flag)
train$shot_made_flag <- factor(train$shot_made_flag, levels = c("1", "0"))
#handle with the train features
train$shot_distance[train$shot_distance > 40] <- 40
train$time_remaining <- train$minutes_remaining*60 + train$seconds_remaining
#normalize function
myNormalize <- function (target) {
(target - min(target))/(max(target) - min(target))
}
train$shot_distance <- myNormalize(train$shot_distance)
train$time_remaining <- myNormalize(train$time_remaining)
#create subset of train to predict
train_dat <- data.frame(train$shot_distance, train$time_remaining, train$shot_made_flag)
colnames(train_dat) <- c("shot_distance", "time_remaining", "shot_made_flag")
colnames(train_dat) <- make.names(colnames(train_dat))
train_dat <- train_dat[order(train_dat$shot_made_flag), ] # order by shot_made_flag
#handle with the test features
test$shot_distance[test$shot_distance > 40] <- 40
test$time_remaining <- test$minutes_remaining*60 + test$seconds_remaining;
test$shot_distance <- myNormalize(test$shot_distance)
test$time_remaining <- myNormalize(test$time_remaining)
#create subset of test to predict
test_dat <- data.frame(test$shot_distance, test$time_remaining, test$shot_made_flag)
colnames(test_dat) <- c("shot_distance", "time_remaining", "shot_made_flag")
colnames(test_dat) <- make.names(colnames(test_dat))
glm <- glm(shot_made_flag~., data=train_dat, family = binomial(link = "logit"))
pred <- predict(glm, train_dat)
trainig_error <- mean(train_dat$shot_made_flag != pred) * 100
paste("Trainig_error =", trainig_error, "%")
confusionMatrix(pred, train_dat$shot_made_flag)
confusionMatrix(pred, train_dat$shot_made_flag)
pred <- predict(glm, train_dat)
trainig_error <- mean(train_dat$shot_made_flag != pred) * 100
paste("Trainig_error =", trainig_error, "%")
newdata <- data.frame(train_dat[,-3])
pred_train <- predict(model, newdata)
#predict
library(data.table)
data <- as.data.frame(fread("data.csv", header = TRUE, stringsAsFactors = TRUE))
##dropping unneeded variables
drops <- c("game_event_id", "game_id", "loc_x", "loc_y", "lat", "lon",
"shot_zone_area", "shot_zone_basic", "shot_zone_range",
"team_id", "team_name", "game_date", "matchup",
"minutes_remaining", "seconds_remaining")
cat("splitting data to train and test......\n")
train <- data[!is.na(data$shot_made_flag),]
test <- data[is.na(data$shot_made_flag),]
cat("precessing the train data......\n")
train$shot_made_flag <- as.factor(train$shot_made_flag)
outliers <- boxplot(train$shot_distance, plot=FALSE)$out
min(outliers)
#handle with the train features
train$shot_distance[train$shot_distance > 40] <- 40
train$time_remaining <- train$minutes_remaining * 60 + train$seconds_remaining
train <- train[ , !(names(train) %in% drops)]
#normalize function
myNormalize <- function (target) {
(target - min(target))/(max(target) - min(target))
}
train$shot_distance <- myNormalize(train$shot_distance)
train$time_remaining <- myNormalize(train$time_remaining)
train_dat <- data.frame(train$shot_distance, train$time_remaining, train$shot_made_flag)
colnames(train_dat) <- c("shot_distance", "time_remaining", "shot_made_flag")
#handle with the test features
test$shot_distance[test$shot_distance > 40] <- 40
test$time_remaining <- test$minutes_remaining * 60 + test$seconds_remaining
test <- test[ , !(names(test) %in% drops)]
test$shot_distance <- myNormalize(test$shot_distance)
test$time_remaining <- myNormalize(test$time_remaining)
test_dat <- data.frame(test$shot_distance, test$time_remaining, test$shot_made_flag)
colnames(test_dat) <- c("shot_distance", "time_remaining", "shot_made_flag")
#build model by train data
model <- glm(shot_made_flag~., data=train_dat, family = binomial(link = "logit"))
#anova(model)
#show accuracy by train data
newdata <- data.frame(train_dat[,-3])
pred_train <- predict(model, newdata)
pred_train
pred_train["names"]
pred_train["class"]
pred_train[1]
pred_train$shot_made_flag <- myNormalize(pred_train$shot_made_flag)
newdata <- data.frame(train_dat[,-3])
pred_train <- predict(model, newdata, type = 'response')
newdata <- data.frame(train_dat[,-3])
pred <- predict(model, newdata, type = 'response')
#predict
library(data.table)
data <- as.data.frame(fread("data.csv", header = TRUE, stringsAsFactors = TRUE))
##dropping unneeded variables
drops <- c("game_event_id", "game_id", "loc_x", "loc_y", "lat", "lon",
"shot_zone_area", "shot_zone_basic", "shot_zone_range",
"team_id", "team_name", "game_date", "matchup",
"minutes_remaining", "seconds_remaining")
cat("splitting data to train and test......\n")
train <- data[!is.na(data$shot_made_flag),]
test <- data[is.na(data$shot_made_flag),]
cat("precessing the train data......\n")
train$shot_made_flag <- as.factor(train$shot_made_flag)
outliers <- boxplot(train$shot_distance, plot=FALSE)$out
min(outliers)
#handle with the train features
train$shot_distance[train$shot_distance > 40] <- 40
train$time_remaining <- train$minutes_remaining * 60 + train$seconds_remaining
train <- train[ , !(names(train) %in% drops)]
#normalize function
myNormalize <- function (target) {
(target - min(target))/(max(target) - min(target))
}
train$shot_distance <- myNormalize(train$shot_distance)
train$time_remaining <- myNormalize(train$time_remaining)
train_dat <- data.frame(train$shot_distance, train$time_remaining, train$shot_made_flag)
colnames(train_dat) <- c("shot_distance", "time_remaining", "shot_made_flag")
#handle with the test features
test$shot_distance[test$shot_distance > 40] <- 40
test$time_remaining <- test$minutes_remaining * 60 + test$seconds_remaining
test <- test[ , !(names(test) %in% drops)]
test$shot_distance <- myNormalize(test$shot_distance)
test$time_remaining <- myNormalize(test$time_remaining)
test_dat <- data.frame(test$shot_distance, test$time_remaining, test$shot_made_flag)
colnames(test_dat) <- c("shot_distance", "time_remaining", "shot_made_flag")
#build model by train data
model <- glm(shot_made_flag~., data=train_dat, family = binomial(link = "logit"))
#anova(model)
#show accuracy by train data
newdata <- data.frame(train_dat[,-3])
pred <- predict(model, newdata, type = 'response')
newdata <- data.frame(train_dat[,-3])
pred <- predict(model, newdata, type = 'response')
submission <- data.frame(shot_id=test$shot_id, shot_made_flag=pred)
newdata <- data.frame(test_dat[,-3])
pred <- predict(model, newdata, type = 'response')
submission <- data.frame(shot_id=test$shot_id, shot_made_flag=pred)
table_mat <- table(submission$shot_made_flag, pred > 0.5)
table_mat
newdata <- data.frame(test_dat[,-3])
pred <- predict(model, newdata, type = 'response')
submission <- data.frame(shot_made_flag=pred)
submission$shot_made_flag <- myNormalize(submission$shot_made_flag)
table_mat <- table(submission$shot_made_flag, pred > 0.5)
table_mat
accuracy_Test <- sum(diag(table_mat)) / sum(table_mat)
accuracy_Test
newdata <- data.frame(train_dat[,-3])
pred <- predict(model, newdata, type = 'response')
submission <- data.frame(shot_made_flag=pred)
submission$shot_made_flag <- myNormalize(submission$shot_made_flag)
table_mat <- table(submission$shot_made_flag, pred > 0.5)
table_mat
accuracy_Test <- sum(diag(table_mat)) / sum(table_mat)
accuracy_Test
newdata <- data.frame(train_dat[,-3])
pred <- predict(model, newdata, type = 'response')
glm <- train(shot_made_flag ~ .,
data=train_dat,
method = 'glm', family = 'binomial',
trControl=fitControl)
fitControl <- trainControl(method = "cv",
number = 5,
verboseIter = TRUE)
glm <- train(shot_made_flag ~ .,
data=train_dat,
method = 'glm', family = 'binomial',
trControl=fitControl)
glm
#predict
library(data.table)
data <- as.data.frame(fread("data.csv", header = TRUE, stringsAsFactors = TRUE))
##dropping unneeded variables
drops <- c("game_event_id", "game_id", "loc_x", "loc_y", "lat", "lon",
"shot_zone_area", "shot_zone_basic", "shot_zone_range",
"team_id", "team_name", "game_date", "matchup",
"minutes_remaining", "seconds_remaining")
cat("splitting data to train and test......\n")
train <- data[!is.na(data$shot_made_flag),]
test <- data[is.na(data$shot_made_flag),]
cat("precessing the train data......\n")
train$shot_made_flag <- as.factor(train$shot_made_flag)
outliers <- boxplot(train$shot_distance, plot=FALSE)$out
min(outliers)
#handle with the train features
train$shot_distance[train$shot_distance > 40] <- 40
train$time_remaining <- train$minutes_remaining * 60 + train$seconds_remaining
train <- train[ , !(names(train) %in% drops)]
#normalize function
myNormalize <- function (target) {
(target - min(target))/(max(target) - min(target))
}
train$shot_distance <- myNormalize(train$shot_distance)
train$time_remaining <- myNormalize(train$time_remaining)
train_dat <- data.frame(train$shot_distance, train$time_remaining, train$shot_made_flag)
colnames(train_dat) <- c("shot_distance", "time_remaining", "shot_made_flag")
#handle with the test features
test$shot_distance[test$shot_distance > 40] <- 40
test$time_remaining <- test$minutes_remaining * 60 + test$seconds_remaining
test <- test[ , !(names(test) %in% drops)]
test$shot_distance <- myNormalize(test$shot_distance)
test$time_remaining <- myNormalize(test$time_remaining)
test_dat <- data.frame(test$shot_distance, test$time_remaining, test$shot_made_flag)
colnames(test_dat) <- c("shot_distance", "time_remaining", "shot_made_flag")
#build model by train data
model <- glm(shot_made_flag~., data=train_dat, family = binomial(link = "logit"))
#anova(model)
newdata <- data.frame(test_dat[,-3])
preds <- predict(model, newdata, type = 'response');
preds_th <- ifelse(preds > 0.5,1,0)
#predict
library(data.table)
data <- as.data.frame(fread("data.csv", header = TRUE, stringsAsFactors = TRUE))
##dropping unneeded variables
drops <- c("game_event_id", "game_id", "loc_x", "loc_y", "lat", "lon",
"shot_zone_area", "shot_zone_basic", "shot_zone_range",
"team_id", "team_name", "game_date", "matchup",
"minutes_remaining", "seconds_remaining")
cat("splitting data to train and test......\n")
train <- data[!is.na(data$shot_made_flag),]
test <- data[is.na(data$shot_made_flag),]
cat("precessing the train data......\n")
train$shot_made_flag <- as.factor(train$shot_made_flag)
outliers <- boxplot(train$shot_distance, plot=FALSE)$out
min(outliers)
#handle with the train features
train$shot_distance[train$shot_distance > 40] <- 40
train$time_remaining <- train$minutes_remaining * 60 + train$seconds_remaining
train <- train[ , !(names(train) %in% drops)]
#normalize function
myNormalize <- function (target) {
(target - min(target))/(max(target) - min(target))
}
train$shot_distance <- myNormalize(train$shot_distance)
train$time_remaining <- myNormalize(train$time_remaining)
train_dat <- data.frame(train$shot_distance, train$time_remaining, train$shot_made_flag)
colnames(train_dat) <- c("shot_distance", "time_remaining", "shot_made_flag")
#handle with the test features
test$shot_distance[test$shot_distance > 40] <- 40
test$time_remaining <- test$minutes_remaining * 60 + test$seconds_remaining
test <- test[ , !(names(test) %in% drops)]
test$shot_distance <- myNormalize(test$shot_distance)
test$time_remaining <- myNormalize(test$time_remaining)
test_dat <- data.frame(test$shot_distance, test$time_remaining, test$shot_made_flag)
colnames(test_dat) <- c("shot_distance", "time_remaining", "shot_made_flag")
#build model by train data
model <- glm(shot_made_flag~., data=train_dat, family = binomial(link = "logit"))
#anova(model)
# Predict the test set based on the model
# predict generates a vector of probabilities that we threshold at 0.5
newdata <- data.frame(test_dat[,-3])
pred <- predict(model, newdata, type = 'response')
submission <- data.frame(shot_id=test$shot_id, shot_made_flag=pred)
submission$shot_made_flag <- myNormalize(submission$shot_made_flag)
preds_th <- ifelse(pred > 0.5,1,0)
cm <- table(submission$shot_made_flag, preds_th)
accuracy[i] <- (cm[1,1] + cm[2,2]) / (cm[1,1] + cm[2,2] + cm[1,2] + cm[2,1])
cm_model[[i]] <- cm
cm <- table(submission$shot_made_flag, preds_th)
accuracy <- (cm[1,1] + cm[2,2]) / (cm[1,1] + cm[2,2] + cm[1,2] + cm[2,1])
cm_model <- cm
newdata <- data.frame(train_dat[,-3])
pred <- predict(model, newdata, type = 'response')
submission <- data.frame(shot_id=test$shot_id, shot_made_flag=pred)
submission$shot_made_flag <- myNormalize(submission$shot_made_flag)
preds_th <- ifelse(pred > 0.5,1,0)
# Make the Confusion Matrix
cm <- table(submission$shot_made_flag, preds_th)
accuracy <- (cm[1,1] + cm[2,2]) / (cm[1,1] + cm[2,2] + cm[1,2] + cm[2,1])
cm_model <- cm
newdata <- data.frame(train_dat[,-3])
pred <- predict(model, newdata, type = 'response')
submission <- data.frame(shot_id=train$shot_id, shot_made_flag=pred)
submission$shot_made_flag <- myNormalize(submission$shot_made_flag)
preds_th <- ifelse(pred > 0.5,1,0)
cm <- table(submission$shot_made_flag, preds_th)
accuracy <- (cm[1,1] + cm[2,2]) / (cm[1,1] + cm[2,2] + cm[1,2] + cm[2,1])
cm_model <- cm
pred <- predict(rf, train_dat)
trainig_error <- mean(train_dat$shot_made_flag != pred) * 100
paste("Trainig_error =", trainig_error, "%")
confusionMatrix(pred, train_dat$shot_made_flag)
# show accuracy by train data
# predict generates a vector of probabilities that we threshold at 0.5
newdata <- data.frame(train_dat[,-3])
pred <- predict(model, newdata, type = 'response')
newdf <- data.frame(shot_id=train$shot_id, shot_made_flag=pred)
newdf$shot_made_flag <- myNormalize(newdf$shot_made_flag)
preds_th <- ifelse(pred > 0.5,1,0)
# make the Confusion Matrix
cm <- table(submission$shot_made_flag, preds_th)
accuracy <- (cm[1,1] + cm[2,2]) / (cm[1,1] + cm[2,2] + cm[1,2] + cm[2,1])
cm_model <- cm
cm_model
accuracy
trControl <- trainControl(method="cv",number=5,verboseIter=TRUE)
trControl <- trainControl(method="cv",number=5,verboseIter=TRUE)
model <- train(shot_made_flag ~ ., data=train, method="rf",metric="logLoss")
trControl <- trainControl(method="cv",number=5,verboseIter=TRUE)
model <- train(shot_made_flag ~ ., data=train_dat, method="rf")
wts=c(1,1)
names(wts)=c(1,0)
model <- svm(shot_made_flag~., data=train_dat, kernel="radial",  gamma=1, cost=1, class.weights=wts)
library(e1071)
wts=c(1,1)
names(wts)=c(1,0)
model <- svm(shot_made_flag~., data=train_dat, kernel="radial",  gamma=1, cost=1, class.weights=wts)
newdata <- data.frame(train_dat[,-3])
pred <- predict(model, newdata, type = 'response')
newdf <- data.frame(shot_id=train$shot_id, shot_made_flag=pred)
newdf$shot_made_flag <- myNormalize(newdf$shot_made_flag)
preds_th <- ifelse(pred > 0.5,1,0)
newdf <- data.frame(shot_id=train$shot_id, shot_made_flag=pred)
preds_th <- ifelse(pred > 0.5,1,0)
preds_th <- ifelse(as.numeric(pred) > 0.5,1,0)
cm <- table(submission$shot_made_flag, preds_th)
accuracy <- (cm[1,1] + cm[2,2]) / (cm[1,1] + cm[2,2] + cm[1,2] + cm[2,1])
newdata <- data.frame(train_dat[,-3])
pred <- predict(model, newdata, type = 'response')
newdf <- data.frame(shot_id=train$shot_id, shot_made_flag=pred)
newdf$shot_made_flag <- myNormalize(newdf$shot_made_flag)
preds_th <- ifelse(as.numeric(pred) > 0.5,1,0)
# make the Confusion Matrix
cm <- table(newdf$shot_made_flag, preds_th)
accuracy <- (cm[1,1] + cm[2,2]) / (cm[1,1] + cm[2,2] + cm[1,2] + cm[2,1])
newdata <- data.frame(train_dat[,-3])
pred <- predict(model, newdata, type = 'response')
confusionMatrix(pred, train_dat$shot_made_flag)
#predict
library(data.table)
library(e1071)
data <- as.data.frame(fread("data.csv", header = TRUE, stringsAsFactors = TRUE))
##dropping unneeded variables
drops <- c("game_event_id", "game_id", "loc_x", "loc_y", "lat", "lon",
"shot_zone_area", "shot_zone_basic", "shot_zone_range",
"team_id", "team_name", "game_date", "matchup",
"minutes_remaining", "seconds_remaining")
cat("splitting data to train and test......\n")
train <- data[!is.na(data$shot_made_flag),]
test <- data[is.na(data$shot_made_flag),]
cat("precessing the train data......\n")
train$shot_made_flag <- as.factor(train$shot_made_flag)
outliers <- boxplot(train$shot_distance, plot=FALSE)$out
min(outliers)
#handle with the train features
train$shot_distance[train$shot_distance > 40] <- 40
train$time_remaining <- train$minutes_remaining * 60 + train$seconds_remaining
train <- train[ , !(names(train) %in% drops)]
#normalize function
myNormalize <- function (target) {
(target - min(target))/(max(target) - min(target))
}
train$shot_distance <- myNormalize(train$shot_distance)
train$time_remaining <- myNormalize(train$time_remaining)
train_dat <- data.frame(train$shot_distance, train$time_remaining, train$shot_made_flag)
colnames(train_dat) <- c("shot_distance", "time_remaining", "shot_made_flag")
#handle with the test features
test$shot_distance[test$shot_distance > 40] <- 40
test$time_remaining <- test$minutes_remaining * 60 + test$seconds_remaining
test <- test[ , !(names(test) %in% drops)]
test$shot_distance <- myNormalize(test$shot_distance)
test$time_remaining <- myNormalize(test$time_remaining)
test_dat <- data.frame(test$shot_distance, test$time_remaining, test$shot_made_flag)
colnames(test_dat) <- c("shot_distance", "time_remaining", "shot_made_flag")
#build model by train data
#glm
model <- glm(shot_made_flag~., data=train_dat, family = binomial(link = "logit"))
# show accuracy by train data
# predict generates a vector of probabilities that we threshold at 0.5
newdata <- data.frame(train_dat[,-3])
pred <- predict(model, newdata, type = 'response')
newdf <- data.frame(shot_id=train$shot_id, shot_made_flag=pred)
newdf$shot_made_flag <- myNormalize(newdf$shot_made_flag)
preds_th <- ifelse(pred > 0.5,1,0)
# make the Confusion Matrix
cm <- table(newdf$shot_made_flag, preds_th)
accuracy <- (cm[1,1] + cm[2,2]) / (cm[1,1] + cm[2,2] + cm[1,2] + cm[2,1])
wts=c(1,1)
names(wts)=c(1,0)
model <- svm(shot_made_flag~., data=train_dat, kernel="radial",  gamma=1, cost=1, class.weights=wts)
confusionMatrix(pred, train_dat$shot_made_flag)
confusionMatrix(pred, train_dat$shot_made_flag)
#predict
library(data.table)
data <- as.data.frame(fread("data.csv", header = TRUE, stringsAsFactors = TRUE))
##dropping unneeded variables
drops <- c("game_event_id", "game_id", "loc_x", "loc_y", "lat", "lon",
"shot_zone_area", "shot_zone_basic", "shot_zone_range",
"team_id", "team_name", "game_date", "matchup",
"minutes_remaining", "seconds_remaining")
cat("splitting data to train and test......\n")
train <- data[!is.na(data$shot_made_flag),]
test <- data[is.na(data$shot_made_flag),]
cat("precessing the train data......\n")
train$shot_made_flag <- as.factor(train$shot_made_flag)
outliers <- boxplot(train$shot_distance, plot=FALSE)$out
min(outliers)
#handle with the train features
train$shot_distance[train$shot_distance > 40] <- 40
train$time_remaining <- train$minutes_remaining * 60 + train$seconds_remaining
train <- train[ , !(names(train) %in% drops)]
#normalize function
myNormalize <- function (target) {
(target - min(target))/(max(target) - min(target))
}
train$shot_distance <- myNormalize(train$shot_distance)
train$time_remaining <- myNormalize(train$time_remaining)
train_dat <- data.frame(train$shot_distance, train$time_remaining, train$shot_made_flag)
colnames(train_dat) <- c("shot_distance", "time_remaining", "shot_made_flag")
#handle with the test features
test$shot_distance[test$shot_distance > 40] <- 40
test$time_remaining <- test$minutes_remaining * 60 + test$seconds_remaining
test <- test[ , !(names(test) %in% drops)]
test$shot_distance <- myNormalize(test$shot_distance)
test$time_remaining <- myNormalize(test$time_remaining)
test_dat <- data.frame(test$shot_distance, test$time_remaining, test$shot_made_flag)
colnames(test_dat) <- c("shot_distance", "time_remaining", "shot_made_flag")
library(e1071)
wts=c(1,1)
names(wts)=c(1,0)
model <- svm(shot_made_flag~., data=train_dat, kernel="radial",  gamma=1, cost=1, class.weights=wts)
#anova(model)
# show accuracy by train data
# predict generates a vector of probabilities that we threshold at 0.5
newdata <- data.frame(train_dat[,-3])
pred <- predict(model, newdata, type = 'response')
confusionMatrix(pred, train_dat$shot_made_flag)
library(ggplot2)
library(randomForest)
trControl <- trainControl(method="cv",number=5,verboseIter=TRUE)
model <- train(shot_made_flag ~ ., data=train, method="rf")
library(caret)
library(MASS)
library(randomForest)
data <- read.csv("data.csv", sep = "," , stringsAsFactors = FALSE)
library(caret)
library(MASS)
library(randomForest)
data <- read.csv("data.csv", sep = "," , stringsAsFactors = FALSE)
cat("splitting data to train and test......\n")
train <- subset(data, !is.na(data$shot_made_flag))
test <- subset(data, is.na(data$shot_made_flag))
cat("precessing the train data......\n")
train$shot_made_flag <- as.factor(train$shot_made_flag)
train$shot_made_flag <- factor(train$shot_made_flag, levels = c("1", "0"))
#handle with the train features
train$shot_distance[train$shot_distance > 40] <- 40
train$time_remaining <- train$minutes_remaining*60 + train$seconds_remaining
#normalize function
myNormalize <- function (target) {
(target - min(target))/(max(target) - min(target))
}
train$shot_distance <- myNormalize(train$shot_distance)
train$time_remaining <- myNormalize(train$time_remaining)
#create subset of train to predict
train_dat <- data.frame(train$shot_distance, train$time_remaining, train$shot_made_flag)
colnames(train_dat) <- c("shot_distance", "time_remaining", "shot_made_flag")
colnames(train_dat) <- make.names(colnames(train_dat))
train_dat <- train_dat[order(train_dat$shot_made_flag), ] # order by shot_made_flag
#handle with the test features
test$shot_distance[test$shot_distance > 40] <- 40
test$time_remaining <- test$minutes_remaining*60 + test$seconds_remaining;
test$shot_distance <- myNormalize(test$shot_distance)
test$time_remaining <- myNormalize(test$time_remaining)
#create subset of test to predict
test_dat <- data.frame(test$shot_distance, test$time_remaining, test$shot_made_flag)
colnames(test_dat) <- c("shot_distance", "time_remaining", "shot_made_flag")
colnames(test_dat) <- make.names(colnames(test_dat))
fitControl <- trainControl(method = "cv",
number = 5,
verboseIter = TRUE)
rf <- train(shot_made_flag ~ .,
data=train_dat,
method="rf",
trControl=fitControl)
pred <- predict(rf, train_dat)
trainig_error <- mean(train_dat$shot_made_flag != pred) * 100
paste("Trainig_error =", trainig_error, "%")
confusionMatrix(pred, train_dat$shot_made_flag)
