"minutes_remaining", "seconds_remaining")
cat("splitting data to train and test......\n")
train <- data[!is.na(data$shot_made_flag),]
test <- data[is.na(data$shot_made_flag),]
cat("precessing the train data......\n")
train$shot_made_flag <- as.factor(train$shot_made_flag)
outliers <- boxplot(train$shot_distance, plot=FALSE)$out
min(outliers)
#handle with the train features
train$shot_distance[train$shot_distance > 40] <- 40
train$time_remaining <- train$minutes_remaining * 60 + train$seconds_remaining
train <- train[ , !(names(train) %in% drops)]
#normalize function
myNormalize <- function (target) {
(target - min(target))/(max(target) - min(target))
}
train$shot_distance <- myNormalize(train$shot_distance)
train$time_remaining <- myNormalize(train$time_remaining)
train_dat <- data.frame(train$shot_distance, train$time_remaining, train$shot_made_flag)
colnames(train_dat) <- c("shot_distance", "time_remaining", "shot_made_flag")
#handle with the test features
test$shot_distance[test$shot_distance > 40] <- 40
test$time_remaining <- test$minutes_remaining * 60 + test$seconds_remaining
test <- test[ , !(names(test) %in% drops)]
test$shot_distance <- myNormalize(test$shot_distance)
test$time_remaining <- myNormalize(test$time_remaining)
test_dat <- data.frame(test$shot_distance, test$time_remaining, test$shot_made_flag)
colnames(test_dat) <- c("shot_distance", "time_remaining", "shot_made_flag")
#build model by train data
model <- glm(shot_made_flag~., data=train_dat, family = binomial(link = "logit"))
# show accuracy by train data
# predict generates a vector of probabilities that we threshold at 0.5
newdata <- data.frame(train_dat[,-3])
pred <- predict(model, newdata, type = 'response')
newdf <- data.frame(shot_id=train$shot_id, shot_made_flag=pred)
newdf$shot_made_flag <- myNormalize(newdf$shot_made_flag)
preds_th <- ifelse(as.numeric(pred) > 0.5,1,0)
# make the Confusion Matrix
cm <- table(newdf$shot_made_flag, preds_th)
accuracy <- (cm[1,1] + cm[2,2]) / (cm[1,1] + cm[2,2] + cm[1,2] + cm[2,1])
error <- (1-accuracy) * 100
#predict
library(data.table)
data <- as.data.frame(fread("data.csv", header = TRUE, stringsAsFactors = TRUE))
##dropping unneeded variables
drops <- c("game_event_id", "game_id", "loc_x", "loc_y", "lat", "lon",
"shot_zone_area", "shot_zone_basic", "shot_zone_range",
"team_id", "team_name", "game_date", "matchup",
"minutes_remaining", "seconds_remaining")
cat("splitting data to train and test......\n")
train <- data[!is.na(data$shot_made_flag),]
test <- data[is.na(data$shot_made_flag),]
cat("precessing the train data......\n")
train$shot_made_flag <- as.factor(train$shot_made_flag)
outliers <- boxplot(train$shot_distance, plot=FALSE)$out
min(outliers)
#handle with the train features
train$shot_distance[train$shot_distance > 40] <- 40
train$time_remaining <- train$minutes_remaining * 60 + train$seconds_remaining
train <- train[ , !(names(train) %in% drops)]
#normalize function
myNormalize <- function (target) {
(target - min(target))/(max(target) - min(target))
}
train$shot_distance <- myNormalize(train$shot_distance)
train$time_remaining <- myNormalize(train$time_remaining)
train_dat <- data.frame(train$shot_distance, train$time_remaining, train$shot_made_flag)
colnames(train_dat) <- c("shot_distance", "time_remaining", "shot_made_flag")
#handle with the test features
test$shot_distance[test$shot_distance > 40] <- 40
test$time_remaining <- test$minutes_remaining * 60 + test$seconds_remaining
test <- test[ , !(names(test) %in% drops)]
test$shot_distance <- myNormalize(test$shot_distance)
test$time_remaining <- myNormalize(test$time_remaining)
test_dat <- data.frame(test$shot_distance, test$time_remaining, test$shot_made_flag)
colnames(test_dat) <- c("shot_distance", "time_remaining", "shot_made_flag")
#build model by train data
model <- glm(shot_made_flag~., data=train_dat, family = binomial(link = "logit"))
# show accuracy by train data
# predict generates a vector of probabilities that we threshold at 0.5
newdata <- data.frame(train_dat[,-3])
pred <- predict(model, newdata, type = 'response')
LogLoss<-function(actual, predicted)
{
predicted<-(pmax(predicted, 0.00001))
predicted<-(pmin(predicted, 0.99999))
result<- (-1/length(actual))*(sum((actual*log(predicted)+(1-actual)*log(1-predicted))))
return(result)
}
LogLoss(newdf$shot_made_flag, pred)
LogLoss<-function(actual, predicted)
{
predicted<-(pmax(predicted, 0.00001))
predicted<-(pmin(predicted, 0.99999))
result<- (-1/length(actual))*(sum((actual*log(predicted)+(1-actual)*log(1-predicted))))
return(result)
}
LogLoss(newdata$shot_made_flag, pred)
LogLoss<-function(actual, predicted)
{
predicted<-(pmax(predicted, 0.00001))
predicted<-(pmin(predicted, 0.99999))
result<- (-1/length(actual))*(sum((actual*log(predicted)+(1-actual)*log(1-predicted))))
return(result)
}
LogLoss(train_dat$shot_made_flag, pred)
LogLoss<-function(actual, predicted)
{
predicted<-(pmax(predicted, 0.00001))
predicted<-(pmin(predicted, 0.99999))
result<- (-1/length(actual))*(sum((actual*log(predicted)+(1-actual)*log(1-predicted))))
return(result)
}
LogLoss(newdf$shot_made_flag, pred)
newdf <- data.frame(shot_id=train$shot_id, shot_made_flag=pred)
newdf$shot_made_flag <- myNormalize(newdf$shot_made_flag)
preds_th <- ifelse(as.numeric(pred) > 0.5,1,0)
# make the Confusion Matrix
cm <- table(newdf$shot_made_flag, preds_th)
accuracy <- (cm[1,1] + cm[2,2]) / (cm[1,1] + cm[2,2] + cm[1,2] + cm[2,1])
error <- (1-accuracy) * 100
pred$names
pred["names"]
pred$shot_made_flag
pred
str(pred)
summary(pred)
LogLossBinary = function(actual, predicted, eps = 1e-15) {
+   predicted = pmin(pmax(predicted, eps), 1-eps)
+   - (sum(actual * log(predicted) + (1 - actual) * log(1 - predicted))) / length(actual)
LogLossBinary(1, c(0.5))
)
glmModel <- glm(shot_made_flag ~ ., data = train_dat, family="binomial")
Preds <- predict(glmModel, type = 'response')
logLoss(testDF$y, Preds)
# using s3 method for glm
logLoss(glmModel)
glmModel <- glm(shot_made_flag ~ ., data = train_dat, family="binomial")
Preds <- predict(glmModel, type = 'response')
logLoss(train_dat$shot_distance, Preds)
# using s3 method for glm
logLoss(glmModel)
model <- glm(shot_made_flag~., data=train_dat, family = binomial(link = "logit"))
Preds <- predict(model, type = 'response')
logLoss(train_dat$shot_distance, Preds)
library(ModelMetrics)
logLoss(train_dat$shot_distance, Preds)
# using s3 method for glm
logLoss(glmModel)
newdata <- data.frame(train_dat[,-3])
pred <- predict(model, newdata, type = 'response')
library(ModelMetrics)
logLoss(newdata, Preds)
# using s3 method for glm
logLoss(glmModel)
logLoss(model)
#build model by train data
model <- glm(shot_made_flag~., data=train_dat, family = binomial(link = "logit"))
# show accuracy by train data
# predict generates a vector of probabilities that we threshold at 0.5
newdata <- data.frame(train_dat[,-3])
pred <- predict(model, newdata, type = 'response')
library(ModelMetrics)
logLoss(train_dat$shot_distance, pred)
# using s3 method for glm
logLoss(model)
newdata <- data.frame(test_dat[,-3])
pred <- predict(model, newdata, type = "response")
submission <- data.frame(shot_id=test$shot_id, shot_made_flag=pred)
submission$shot_made_flag <- myNormalize(submission$shot_made_flag)
library(ModelMetrics)
logLoss(test_dat$shot_distance, pred)
# using s3 method for glm
logLoss(model)
#build model by train data
model <- glm(shot_made_flag~., data=train_dat, family = binomial(link = "logit"))
# show accuracy by train data
# predict generates a vector of probabilities that we threshold at 0.5
newdata <- data.frame(train_dat[,-3])
pred <- predict(model, newdata, type = 'response')
library(ModelMetrics)
logLoss(train_dat$shot_made_flag, pred)
print(0.9294118)
print(logLoss)
print(0.9294118)
print(logLoss)
model <- glm(shot_made_flag~., data=train_dat, family = binomial(link = "logit"))
# show accuracy by train data
# predict generates a vector of probabilities that we threshold at 0.5
newdata <- data.frame(train_dat[,-3])
pred <- predict(model, newdata, type = 'response')
library(ModelMetrics)
logLoss(train_dat$shot_made_flag, pred)
# using s3 method for glm
logLoss(model)
newdata <- data.frame(train_dat[,-3])
pred <- predict(model, newdata, type = 'response')
newdf <- data.frame(shot_id=train$shot_id, shot_made_flag=pred)
newdf$shot_made_flag <- normalize(newdf$shot_made_flag)
library(ModelMetrics)
logLoss(train_dat$shot_made_flag, pred)
(cm[1,1] + cm[2,2]) / (cm[1,1] + cm[2,2] + cm[1,2] + cm[2,1])
newdata <- data.frame(train_dat[,-3])
pred <- predict(model, newdata, type = 'response')
newdf <- data.frame(shot_id=train$shot_id, shot_made_flag=pred)
newdf$shot_made_flag <- normalize(newdf$shot_made_flag)
(cm[1,1] + cm[2,2]) / (cm[1,1] + cm[2,2] + cm[1,2] + cm[2,1])
(cm[1,1] + cm[2,2]) / (cm[1,1] + cm[2,2] + cm[1,2] + cm[2,1])
logLoss(train_dat$shot_made_flag, pred)
newdata <- data.frame(train_dat[,-3])
pred <- predict(model, newdata, type = 'response')
newdf <- data.frame(shot_id=train$shot_id, shot_made_flag=pred)
newdf$shot_made_flag <- normalize(newdf$shot_made_flag)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggplot2)
library(data.table)
library(gridExtra)
library(ModelMetrics)
data <- as.data.frame(fread("data.csv", header = TRUE, stringsAsFactors = TRUE))
example <-as.data.frame(fread("sample_submission.csv", header = TRUE, stringsAsFactors = TRUE))
str(data, width = 85, strict.width = "cut")
train <- data[!is.na(data$shot_made_flag), ]
any(is.na(train))
str(train$shot_made_flag)
test <- data[is.na(data$shot_made_flag), ]
any(is.na(test))
str(test$shot_made_flag)
tmp_data <- read_csv("data.csv")
tmp_data <- na.omit(tmp_data)
qplot(factor(shot_made_flag), data = tmp_data, geom = "bar",
fill = factor(shot_made_flag, levels = c(0, 1))) +
scale_fill_manual(values = c("darkblue", "darkgreen")) +
labs(fill = "levels") + xlab("shot_made_flag") +
ylab("count") + ggtitle("DistribuciÃ³n de la varaible clase") +
theme_bw() + theme(plot.title = element_text(hjust = 0.5))
tmp_data %>%
group_by(season) %>%
summarise(Accuracy=mean(shot_made_flag)) %>%
ggplot(aes(x=season, y=Accuracy, group=1)) +
geom_line(aes(colour=Accuracy)) +
geom_point(aes(colour=Accuracy), size=3) +
scale_colour_gradient(low="orangered", high="chartreuse3") +
labs(title="Accuracy por temporada", x="Season") +
theme(legend.position="none",
plot.title=element_text(hjust=0.5),
axis.text.x=element_text(angle=45, hjust=1))
tmp_data %>%
group_by(shot_distance) %>%
summarise(Accuracy=mean(shot_made_flag)) %>%
ggplot(aes(x=shot_distance, y=Accuracy)) +
geom_line(aes(colour=Accuracy)) +
geom_point(aes(colour=Accuracy), size=2) +
scale_colour_gradient(low="orangered", high="chartreuse3") +
labs(title="Accuracy por distancia", x="Shot distance (ft.)") +
xlim(c(0,45)) +
theme_bw() +
theme(legend.position="none",
plot.title=element_text(hjust=0.5))
qplot(factor(shot_made_flag), shot_distance,  data = tmp_data, geom = "boxplot") +
xlab("shot_made_flag") + ylab("shot_distance")
str(train$shot_made_flag)
train$shot_made_flag <- as.factor(train$shot_made_flag)
str(train$shot_made_flag)
train$time_remaining <- train$minutes_remaining * 60 + train$seconds_remaining
test$time_remaining <- test$minutes_remaining * 60 + test$seconds_remaining
head(example, 5)
normalize <- function (target) {
(target - min(target))/(max(target) - min(target))
}
train$shot_distance <- normalize(train$shot_distance)
test$shot_distance <- normalize(test$shot_distance)
train$time_remaining <- normalize(train$time_remaining)
test$time_remaining <- normalize(test$time_remaining)
p1 <- ggplot(tmp_data, aes(x=lon, y=lat)) +
geom_point(aes(color=shot_zone_range)) +
labs(title="Shot zone range") +
ylim(c(33.7, 34.0883)) +
theme_void() +
theme(legend.position="none",
plot.title=element_text(hjust=0.5))
p2 <- ggplot(tmp_data, aes(x=fct_infreq(shot_zone_range))) +
geom_bar(aes(fill=shot_zone_range)) +
labs(y="Frequency") +
theme_bw() +
theme(axis.title.x=element_blank(),
legend.position="none")
grid.arrange(p1, p2, layout_matrix=cbind(c(1,2)))
drops <- c("game_event_id", "game_id", "loc_x", "loc_y", "lat", "lon",
"shot_zone_area", "shot_zone_basic", "shot_zone_range",
"team_id", "team_name", "game_date", "matchup",
"minutes_remaining", "seconds_remaining")
train$shot_distance[train$shot_distance > 40] <- 40
test$shot_distance[test$shot_distance > 40] <- 40
train <- train[ , !(names(train) %in% drops)]
test <- test[ , !(names(test) %in% drops)]
str(train, width = 85, strict.width = "cut")
str(test, width = 85, strict.width = "cut")
train_dat <- data.frame(train$shot_distance, train$time_remaining, train$shot_made_flag)
colnames(train_dat) <- c("shot_distance", "time_remaining", "shot_made_flag")
train_dat <- train_dat[order(-train_dat$time_remaining),]
test_dat <- data.frame(test$shot_distance, test$time_remaining, test$shot_made_flag)
colnames(test_dat) <- c("shot_distance", "time_remaining", "shot_made_flag")
test_dat <- test_dat[order(-test_dat$time_remaining),]
#str(train_dat, width = 85, strict.width = "cut")
head(train_dat, 5)
#str(test_dat, width = 85, strict.width = "cut")
head(test_dat, 5)
ggplot(data = train_dat, aes(x = shot_made_flag, y = shot_distance, color = shot_made_flag)) +
geom_boxplot() +
geom_jitter(width = 0.1) +
theme_bw() +
theme(legend.position = "null")
model <- glm(shot_made_flag~., data=train_dat, family = binomial(link = "logit"))
summary(model)
newdata <- data.frame(train_dat[,-3])
pred <- predict(model, newdata, type = 'response')
newdf <- data.frame(shot_id=train$shot_id, shot_made_flag=pred)
newdf$shot_made_flag <- normalize(newdf$shot_made_flag)
preds_th <- ifelse(as.numeric(pred) > 0.5,1,0)
# confusion matrix
cm <- table(newdf$shot_made_flag, preds_th)
cm
(cm[1,1] + cm[2,2]) / (cm[1,1] + cm[2,2] + cm[1,2] + cm[2,1])
newdata <- data.frame(test_dat[,-3])
pred <- predict(model, newdata, type = "response")
submission <- data.frame(shot_id=test$shot_id, shot_made_flag=pred)
normalize <- function (target) {
(target - min(target))/(max(target) - min(target))
}
submission$shot_made_flag <- normalize(submission$shot_made_flag)
submission <- read.csv("glm.csv")
head(submission, 10)
newdata <- data.frame(train_dat[,-3])
pred <- predict(model, newdata, type = 'response')
newdf <- data.frame(shot_id=train$shot_id, shot_made_flag=pred)
normalize <- function (target) {
(target - min(target))/(max(target) - min(target))
}
newdf$shot_made_flag <- normalize(newdf$shot_made_flag)
preds_th <- ifelse(as.numeric(pred) > 0.5,1,0)
# confusion matrix
cm <- table(newdf$shot_made_flag, preds_th)
cm
(cm[1,1] + cm[2,2]) / (cm[1,1] + cm[2,2] + cm[1,2] + cm[2,1])
newdata <- data.frame(test_dat[,-3])
pred <- predict(model, newdata, type = "response")
submission <- data.frame(shot_id=test$shot_id, shot_made_flag=pred)
normalize <- function (target) {
(target - min(target))/(max(target) - min(target))
}
submission$shot_made_flag <- normalize(submission$shot_made_flag)
newdata <- data.frame(train_dat[,-3])
pred <- predict(model, newdata, type = 'response')
newdf <- data.frame(shot_id=train$shot_id, shot_made_flag=pred)
normalize <- function (target) {
(target - min(target))/(max(target) - min(target))
}
newdf$shot_made_flag <- normalize(newdf$shot_made_flag)
preds_th <- ifelse(as.numeric(pred) > 0.5,1,0)
# confusion matrix
cm <- table(newdf$shot_made_flag, preds_th)
accuracy <- (cm[1,1] + cm[2,2]) / (cm[1,1] + cm[2,2] + cm[1,2] + cm[2,1])
loglogg <- logLoss(train_dat$shot_made_flag, pred)
newdata <- data.frame(train_dat[,-3])
pred <- predict(model, newdata, type = 'response')
newdf <- data.frame(shot_id=train$shot_id, shot_made_flag=pred)
normalize <- function (target) {
(target - min(target))/(max(target) - min(target))
}
newdf$shot_made_flag <- normalize(newdf$shot_made_flag)
preds_th <- ifelse(as.numeric(pred) > 0.5,1,0)
# confusion matrix
cm <- table(newdf$shot_made_flag, preds_th)
accuracy <- (cm[1,1] + cm[2,2]) / (cm[1,1] + cm[2,2] + cm[1,2] + cm[2,1])
loglogg <- logLoss(train_dat$shot_made_flag, pred)
newdata <- data.frame(train_dat[,-3])
pred <- predict(model, newdata, type = 'response')
newdf <- data.frame(shot_id=train$shot_id, shot_made_flag=pred)
normalize <- function (target) {
(target - min(target))/(max(target) - min(target))
}
newdf$shot_made_flag <- normalize(newdf$shot_made_flag)
preds_th <- ifelse(as.numeric(pred) > 0.5,1,0)
# confusion matrix
cm <- table(newdf$shot_made_flag, preds_th)
accuracy <- (cm[1,1] + cm[2,2]) / (cm[1,1] + cm[2,2] + cm[1,2] + cm[2,1])
accuracy
loglogg <- logLoss(train_dat$shot_made_flag, pred)
loglogg
unlink('document_cache', recursive = TRUE)
#main
library(data.table)
library(ModelMetrics)
data <- as.data.frame(fread("data.csv", header = TRUE, stringsAsFactors = TRUE))
##dropping unneeded variables
drops <- c("game_event_id", "game_id", "loc_x", "loc_y", "lat", "lon",
"shot_zone_area", "shot_zone_basic", "shot_zone_range",
"team_id", "team_name", "game_date", "matchup",
"minutes_remaining", "seconds_remaining")
cat("splitting data to train and test......\n")
train <- data[!is.na(data$shot_made_flag),]
test <- data[is.na(data$shot_made_flag),]
cat("precessing the train data......\n")
train$shot_made_flag <- as.factor(train$shot_made_flag)
outliers <- boxplot(train$shot_distance, plot=FALSE)$out
min(outliers)
#handle with the train features
train$shot_distance[train$shot_distance > 40] <- 40
train$time_remaining <- train$minutes_remaining * 60 + train$seconds_remaining
train <- train[ , !(names(train) %in% drops)]
#normalize function
myNormalize <- function (target) {
(target - min(target))/(max(target) - min(target))
}
train$shot_distance <- myNormalize(train$shot_distance)
train$time_remaining <- myNormalize(train$time_remaining)
train_dat <- data.frame(train$shot_distance, train$time_remaining, train$shot_made_flag)
colnames(train_dat) <- c("shot_distance", "time_remaining", "shot_made_flag")
#handle with the test features
test$shot_distance[test$shot_distance > 40] <- 40
test$time_remaining <- test$minutes_remaining * 60 + test$seconds_remaining
test <- test[ , !(names(test) %in% drops)]
test$shot_distance <- myNormalize(test$shot_distance)
test$time_remaining <- myNormalize(test$time_remaining)
test_dat <- data.frame(test$shot_distance, test$time_remaining, test$shot_made_flag)
colnames(test_dat) <- c("shot_distance", "time_remaining", "shot_made_flag")
#build model by train data
model <- glm(shot_made_flag~., data=train_dat, family = binomial(link = "logit"))
# show accuracy and logloss by train data
# predict generates a vector of probabilities that we threshold at 0.5
newdata <- data.frame(train_dat[,-3])
pred <- predict(model, newdata, type = 'response')
newdf <- data.frame(shot_id=train$shot_id, shot_made_flag=pred)
newdf$shot_made_flag <- myNormalize(newdf$shot_made_flag)
preds_th <- ifelse(as.numeric(pred) > 0.5,1,0)
# make the Confusion Matrix
cm <- table(newdf$shot_made_flag, preds_th)
accuracy <- (cm[1,1] + cm[2,2]) / (cm[1,1] + cm[2,2] + cm[1,2] + cm[2,1])
logLoss(train_dat$shot_made_flag, pred)
#model predict the test data
newdata <- data.frame(test_dat[,-3])
pred <- predict(model, newdata, type = "response")
submission <- data.frame(shot_id=test$shot_id, shot_made_flag=pred)
submission$shot_made_flag <- myNormalize(submission$shot_made_flag)
# make the Confusion Matrix
cm <- table(newdf$shot_made_flag, preds_th)
accuracy <- (cm[1,1] + cm[2,2]) / (cm[1,1] + cm[2,2] + cm[1,2] + cm[2,1])
error <- (1-accuracy) * 100
cat("saving the submission file\n");
write.csv(submission, "glm.csv", row.names = FALSE)
#main
library(data.table)
library(ModelMetrics)
data <- as.data.frame(fread("data.csv", header = TRUE, stringsAsFactors = TRUE))
##dropping unneeded variables
drops <- c("game_event_id", "game_id", "loc_x", "loc_y", "lat", "lon",
"shot_zone_area", "shot_zone_basic", "shot_zone_range",
"team_id", "team_name", "game_date", "matchup",
"minutes_remaining", "seconds_remaining")
cat("splitting data to train and test......\n")
train <- data[!is.na(data$shot_made_flag),]
test <- data[is.na(data$shot_made_flag),]
cat("precessing the train data......\n")
train$shot_made_flag <- as.factor(train$shot_made_flag)
outliers <- boxplot(train$shot_distance, plot=FALSE)$out
min(outliers)
#handle with the train features
train$shot_distance[train$shot_distance > 40] <- 40
train$time_remaining <- train$minutes_remaining * 60 + train$seconds_remaining
train <- train[ , !(names(train) %in% drops)]
#normalize function
myNormalize <- function (target) {
(target - min(target))/(max(target) - min(target))
}
train$shot_distance <- myNormalize(train$shot_distance)
train$time_remaining <- myNormalize(train$time_remaining)
train_dat <- data.frame(train$shot_distance, train$time_remaining, train$shot_made_flag)
colnames(train_dat) <- c("shot_distance", "time_remaining", "shot_made_flag")
#handle with the test features
test$shot_distance[test$shot_distance > 40] <- 40
test$time_remaining <- test$minutes_remaining * 60 + test$seconds_remaining
test <- test[ , !(names(test) %in% drops)]
test$shot_distance <- myNormalize(test$shot_distance)
test$time_remaining <- myNormalize(test$time_remaining)
test_dat <- data.frame(test$shot_distance, test$time_remaining, test$shot_made_flag)
colnames(test_dat) <- c("shot_distance", "time_remaining", "shot_made_flag")
#build model by train data
model <- glm(shot_made_flag~., data=train_dat, family = binomial(link = "logit"))
# show accuracy and logloss by train data
# predict generates a vector of probabilities that we threshold at 0.5
newdata <- data.frame(train_dat[,-3])
pred <- predict(model, newdata, type = 'response')
newdf <- data.frame(shot_id=train$shot_id, shot_made_flag=pred)
newdf$shot_made_flag <- myNormalize(newdf$shot_made_flag)
preds_th <- ifelse(as.numeric(pred) > 0.5,1,0)
# make the Confusion Matrix
cm <- table(newdf$shot_made_flag, preds_th)
accuracy <- (cm[1,1] + cm[2,2]) / (cm[1,1] + cm[2,2] + cm[1,2] + cm[2,1])
accuracy
logLoss(train_dat$shot_made_flag, pred)
#model predict the test data
newdata <- data.frame(test_dat[,-3])
pred <- predict(model, newdata, type = "response")
submission <- data.frame(shot_id=test$shot_id, shot_made_flag=pred)
submission$shot_made_flag <- myNormalize(submission$shot_made_flag)
# make the Confusion Matrix
cm <- table(newdf$shot_made_flag, preds_th)
accuracy <- (cm[1,1] + cm[2,2]) / (cm[1,1] + cm[2,2] + cm[1,2] + cm[2,1])
error <- (1-accuracy) * 100
cat("saving the submission file\n");
write.csv(submission, "glm.csv", row.names = FALSE)
